,institution,elective,overview,title,summary,content,ilo
0,Durham_England,COMP3421,"<h2>Durham_England COMP3421</h2><h2>title</h2>COMP3421: 
COMPUTER SCIENCE INTO SCHOOLS<h2>summary</h2>
			<li>To develop a range of key skills in the student and to offer an early taste of teaching to those interested in pursuing it as a career or for other career pathways where public understanding of science is required.</li>
			<li>To help students gain confidence in communicating Computer Science, develop strong organisational and interpersonal skills, and understand how to address the needs of individuals.</li>
			<li>To learn to devise and develop Computer Science projects and teaching methods appropriate to engage the relevant age group they are working with.</li>
			<li>To help inspire a new generation of Computer Scientists as prospective undergraduates by providing role models for school pupils.</li>
			<li>To help teachers convey the excitement of their subject to pupils by showing them the long-term applications of school studies, especially the cross disciplinary relationships of Computer Science.</li>
			<li>To help teachers by providing an assistant who can work with and support pupils at any point on the ability spectrum.</li>
		<h2>content</h2>
			<li>A competitive interview system will be used to match students with appropriate schools and a specific teacher in the local area, and each student selected will be given a chance to visit the school they will be working in before commencement of the placement.  </li>
			<li>One day training course on working in schools and with pupils.  </li>
			<li>Series of lectures on key transferable skills.  </li>
			<li>The student will be required to spend half a day (approx 4hrs) a week in the school every week for at least 10 weeks.  </li>
			<li>Tutorials which will provide an opportunity for students to share their experiences.  </li>
			<li>The students will be involved in the following activities in support of their learning and teaching:  </li>
			<li>Classroom observation and assistance: Initial contact with the teacher and pupils will be as a classroom assistant, watching how the teacher handles the class, observing the level being taught and the structure of the lesson, and offering practical support to the teacher.  </li>
			<li>Teaching assistance: The teacher will assign the student with actual teaching tasks, which will vary dependent on specific needs and the student's own ability as it develops over the term. This could include for example offering problem-solving coaching to a smaller group of higher ability pupils, or taking the last ten minutes of the lesson for the whole class. The student will have to demonstrate an understanding of how the level of the knowledge of the pupils they are teaching fits in to their overall learning context in other subjects.  </li>
			<li>Whole class teaching: Students will typically be offered, in collaboration with their teachers, at least one opportunity to undertake whole class teaching, albeit that it may be only for a small part of the lesson.  </li>
			<li>University awareness: Students will represent and promote their academic discipline as a potential university choice to pupils across the social and academic range represented at their partner schools.  </li>
			<li>Special projects: The student will devise a special Computer Science project on the basis of discussion with the teacher and module co-ordinator and their own assessment of what will interest the particular pupils they are working with. The student will implement the special project and evaluate it. The student will be required to show that they can analyse a specific teaching problem and devise and prepare appropriately targeted teaching materials, practical demonstrations and basis 'tests' where appropriate.  </li>
			<li>Extra-curricular projects: The student may be supervised by the teacher in helping to run an out-of-timetable activity, such as a lunchtime club or special coaching periods for higher ability pupils. The student will have to demonstrate an ability to think laterally in order to formulate interesting ways to illustrate more difficult scientific concepts.  </li>
			<li>Written reports: The student will keep a journal of their own progress in working in the classroom environment, and they will be asked to prepare a written report on the special project.  </li>
			<li>The teachers will act as the main source of guidance in the schools but, in addition, the students will also be able to discuss progress with the module co-ordinator or a member of the Science Outreach and Engagement Team whenever necessary.</li>
			<li>Solutional methods for computational problems.</li>
		<h2>ilo</h2>
				<li>On successful completion of this module students: </li>
				<li>Will be able to assess and devise appropriate ways to communicate a difficult principle or concept.</li>
				<li>Will have gained a broad understanding of many of the key aspects of teaching in schools.</li>
				<li>Will have an advanced understanding of Computer Science through having to explain to others.</li>
				<li>Will have an advanced understanding of the problems of public perception of science.  </li>
			","COMP3421: 
COMPUTER SCIENCE INTO SCHOOLS","
			<li>To develop a range of key skills in the student and to offer an early taste of teaching to those interested in pursuing it as a career or for other career pathways where public understanding of science is required.</li>
			<li>To help students gain confidence in communicating Computer Science, develop strong organisational and interpersonal skills, and understand how to address the needs of individuals.</li>
			<li>To learn to devise and develop Computer Science projects and teaching methods appropriate to engage the relevant age group they are working with.</li>
			<li>To help inspire a new generation of Computer Scientists as prospective undergraduates by providing role models for school pupils.</li>
			<li>To help teachers convey the excitement of their subject to pupils by showing them the long-term applications of school studies, especially the cross disciplinary relationships of Computer Science.</li>
			<li>To help teachers by providing an assistant who can work with and support pupils at any point on the ability spectrum.</li>
		","
			<li>A competitive interview system will be used to match students with appropriate schools and a specific teacher in the local area, and each student selected will be given a chance to visit the school they will be working in before commencement of the placement.  </li>
			<li>One day training course on working in schools and with pupils.  </li>
			<li>Series of lectures on key transferable skills.  </li>
			<li>The student will be required to spend half a day (approx 4hrs) a week in the school every week for at least 10 weeks.  </li>
			<li>Tutorials which will provide an opportunity for students to share their experiences.  </li>
			<li>The students will be involved in the following activities in support of their learning and teaching:  </li>
			<li>Classroom observation and assistance: Initial contact with the teacher and pupils will be as a classroom assistant, watching how the teacher handles the class, observing the level being taught and the structure of the lesson, and offering practical support to the teacher.  </li>
			<li>Teaching assistance: The teacher will assign the student with actual teaching tasks, which will vary dependent on specific needs and the student's own ability as it develops over the term. This could include for example offering problem-solving coaching to a smaller group of higher ability pupils, or taking the last ten minutes of the lesson for the whole class. The student will have to demonstrate an understanding of how the level of the knowledge of the pupils they are teaching fits in to their overall learning context in other subjects.  </li>
			<li>Whole class teaching: Students will typically be offered, in collaboration with their teachers, at least one opportunity to undertake whole class teaching, albeit that it may be only for a small part of the lesson.  </li>
			<li>University awareness: Students will represent and promote their academic discipline as a potential university choice to pupils across the social and academic range represented at their partner schools.  </li>
			<li>Special projects: The student will devise a special Computer Science project on the basis of discussion with the teacher and module co-ordinator and their own assessment of what will interest the particular pupils they are working with. The student will implement the special project and evaluate it. The student will be required to show that they can analyse a specific teaching problem and devise and prepare appropriately targeted teaching materials, practical demonstrations and basis 'tests' where appropriate.  </li>
			<li>Extra-curricular projects: The student may be supervised by the teacher in helping to run an out-of-timetable activity, such as a lunchtime club or special coaching periods for higher ability pupils. The student will have to demonstrate an ability to think laterally in order to formulate interesting ways to illustrate more difficult scientific concepts.  </li>
			<li>Written reports: The student will keep a journal of their own progress in working in the classroom environment, and they will be asked to prepare a written report on the special project.  </li>
			<li>The teachers will act as the main source of guidance in the schools but, in addition, the students will also be able to discuss progress with the module co-ordinator or a member of the Science Outreach and Engagement Team whenever necessary.</li>
			<li>Solutional methods for computational problems.</li>
		","
				<li>On successful completion of this module students: </li>
				<li>Will be able to assess and devise appropriate ways to communicate a difficult principle or concept.</li>
				<li>Will have gained a broad understanding of many of the key aspects of teaching in schools.</li>
				<li>Will have an advanced understanding of Computer Science through having to explain to others.</li>
				<li>Will have an advanced understanding of the problems of public perception of science.  </li>
			"
8,Durham_England,COMP3547,"<h2>Durham_England COMP3547</h2><h2>title</h2>COMP3547: 
DEEP LEARNING<h2>summary</h2>
			<li>To enable students to be able to approach complex ill-defined problems that require deep layers of learning, and understand how this relates to learning in nature.</li>
			<li>To equip students with the ability to use modern deep learning libraries in order to effectively design, train, and test neural networks in different applications.</li>
		<h2>content</h2>
			<li>Foundations of deep learning and learning in nature</li>
			<li>PyTorch programming</li>
			<li>Designing deep neural network architectures</li>
			<li>Adversarial models</li>
			<li>Energy-based models and Flow models</li>
			<li>Sequential models and Transformers</li>
			<li>Implicit representations</li>
			<li>Generalisation theory</li>
			<li>Meta and manifold learning</li>
		<h2>ilo</h2>
				<li>On completion of the module, students will be able to demonstrate:</li>
				<li>an understanding of state-of-the-art deep neural network architectures and neural network architecture components.</li>
				<li>an understanding of statistical learning theory with deep learning approaches.</li>
				<li>an understanding of the algorithms and approaches to design and evaluate deep neural networks.</li>
			","COMP3547: 
DEEP LEARNING","
			<li>To enable students to be able to approach complex ill-defined problems that require deep layers of learning, and understand how this relates to learning in nature.</li>
			<li>To equip students with the ability to use modern deep learning libraries in order to effectively design, train, and test neural networks in different applications.</li>
		","
			<li>Foundations of deep learning and learning in nature</li>
			<li>PyTorch programming</li>
			<li>Designing deep neural network architectures</li>
			<li>Adversarial models</li>
			<li>Energy-based models and Flow models</li>
			<li>Sequential models and Transformers</li>
			<li>Implicit representations</li>
			<li>Generalisation theory</li>
			<li>Meta and manifold learning</li>
		","
				<li>On completion of the module, students will be able to demonstrate:</li>
				<li>an understanding of state-of-the-art deep neural network architectures and neural network architecture components.</li>
				<li>an understanding of statistical learning theory with deep learning approaches.</li>
				<li>an understanding of the algorithms and approaches to design and evaluate deep neural networks.</li>
			"
83,Glasgow_Scotland,COMPSCI4094,"<h2>Glasgow_Scotland COMPSCI4094</h2><h2>title</h2>Coaching Software Teams (H) COMPSCI4094<h2>summary</h2><p id=""_COMPSCI40940""><span id=""_COMPSCI40941"">This course gives students the opportunity to learn and practice principles, practices and methods used in coaching Software Engineering teams.  The course is intended for students who have experience of software development through a summer internship or similar. The course covers interpersonal and management skills that are needed for mentoring and leading teams of software developers. The course focuses on whole-team coaching and how to introduce and embed software engineering practices in existing teams. The course is delivered in collaboration with an established software industry partner (JP Morgan).</span></p><h2>content</h2><p id=""_COMPSCI409431""><span id=""_COMPSCI409432"">To introduce advanced principles, practices and methods used in whole-team coaching of Software Engineering teams.</span></p><p id=""_COMPSCI409433""><span id=""_COMPSCI409434"">To introduce techniques for effective working in software teams in a mentoring role, </span></p><p id=""_COMPSCI409435""><span id=""_COMPSCI409436"">To expose students to the practicalities and reality of software engineering in industry.</span></p><h2>ilo</h2><p id=""_COMPSCI409437""><span id=""_COMPSCI409438"">By the end of this course students will be able to:</span><span id=""_COMPSCI409439"">&nbsp;</span></p><p id=""_COMPSCI409440""><span id=""_COMPSCI409441"">1. </span><span id=""_COMPSCI409442"">Explain a range of advanced practices in large-scale collaborative software engineering including agile project management, stakeholder management, user research and product discovery;</span></p><p id=""_COMPSCI409443""><span id=""_COMPSCI409444"">2. </span><span id=""_COMPSCI409445"">Apply and adapt mentoring techniques for working with less experienced colleagues;</span></p><p id=""_COMPSCI409446""><span id=""_COMPSCI409447"">3. </span><span id=""_COMPSCI409448"">Identify, plan, implement and evaluate improvements to team software processes;</span></p><p id=""_COMPSCI409449""><span id=""_COMPSCI409450"">4. </span><span id=""_COMPSCI409451"">Be aware of the limitations of existing software engineering practices in large scale systems development.</span></p>",Coaching Software Teams (H) COMPSCI4094,"<p id=""_COMPSCI40940""><span id=""_COMPSCI40941"">This course gives students the opportunity to learn and practice principles, practices and methods used in coaching Software Engineering teams.  The course is intended for students who have experience of software development through a summer internship or similar. The course covers interpersonal and management skills that are needed for mentoring and leading teams of software developers. The course focuses on whole-team coaching and how to introduce and embed software engineering practices in existing teams. The course is delivered in collaboration with an established software industry partner (JP Morgan).</span></p>","<p id=""_COMPSCI409431""><span id=""_COMPSCI409432"">To introduce advanced principles, practices and methods used in whole-team coaching of Software Engineering teams.</span></p><p id=""_COMPSCI409433""><span id=""_COMPSCI409434"">To introduce techniques for effective working in software teams in a mentoring role, </span></p><p id=""_COMPSCI409435""><span id=""_COMPSCI409436"">To expose students to the practicalities and reality of software engineering in industry.</span></p>","<p id=""_COMPSCI409437""><span id=""_COMPSCI409438"">By the end of this course students will be able to:</span><span id=""_COMPSCI409439"">&nbsp;</span></p><p id=""_COMPSCI409440""><span id=""_COMPSCI409441"">1. </span><span id=""_COMPSCI409442"">Explain a range of advanced practices in large-scale collaborative software engineering including agile project management, stakeholder management, user research and product discovery;</span></p><p id=""_COMPSCI409443""><span id=""_COMPSCI409444"">2. </span><span id=""_COMPSCI409445"">Apply and adapt mentoring techniques for working with less experienced colleagues;</span></p><p id=""_COMPSCI409446""><span id=""_COMPSCI409447"">3. </span><span id=""_COMPSCI409448"">Identify, plan, implement and evaluate improvements to team software processes;</span></p><p id=""_COMPSCI409449""><span id=""_COMPSCI409450"">4. </span><span id=""_COMPSCI409451"">Be aware of the limitations of existing software engineering practices in large scale systems development.</span></p>"
97,Glasgow_Scotland,COMPSCI4016,"<h2>Glasgow_Scotland COMPSCI4016</h2><h2>title</h2>Programming Languages (H) COMPSCI4016<h2>summary</h2><p id=""_COMPSCI40160""><span id=""_COMPSCI40161"">This course aims to:</span></p><p id=""_COMPSCI40162""><span id=""_COMPSCI40163"">P</span><span id=""_COMPSCI40164"">rovide a conceptual framework that will enable students to understand familiar programming languages more deeply and learn new languages more efficiently;</span></p><p id=""_COMPSCI40165""><span id=""_COMPSCI40166"">S</span><span id=""_COMPSCI40167"">how how the syntax of a programming language can be formalized;</span></p><p id=""_COMPSCI40168""><span id=""_COMPSCI40169"">E</span><span id=""_COMPSCI401610"">xplain the functions of compilers and interpreters, how they interact, and how they work;</span></p><p id=""_COMPSCI401611""><span id=""_COMPSCI401612"">S</span><span id=""_COMPSCI401613"">how how to implement a compiler using compiler-generation tools.</span></p><h2>content</h2><p id=""_COMPSCI401644""><span id=""_COMPSCI401645"">This course aims to:</span></p><p id=""_COMPSCI401646""><span id=""_COMPSCI401647"">P</span><span id=""_COMPSCI401648"">rovide a conceptual framework that will enable students to understand familiar programming languages more deeply and learn new languages more efficiently;</span></p><p id=""_COMPSCI401649""><span id=""_COMPSCI401650"">S</span><span id=""_COMPSCI401651"">how how the syntax of a programming language can be formalized;</span></p><p id=""_COMPSCI401652""><span id=""_COMPSCI401653"">E</span><span id=""_COMPSCI401654"">xplain the functions of compilers and interpreters, how they interact, and how they work;</span></p><p id=""_COMPSCI401655""><span id=""_COMPSCI401656"">S</span><span id=""_COMPSCI401657"">how how to implement a compiler using compiler-generation tools.</span></p><h2>ilo</h2><p id=""_COMPSCI401659""><span id=""_COMPSCI401660"">By the end of the course students will be able to:</span></p><p id=""_COMPSCI401661""><span id=""_COMPSCI401662"">1. </span><span id=""_COMPSCI401663"">Describe the relationships between the imperative, object-oriented, and functional programming paradigms;</span></p><p id=""_COMPSCI401664""><span id=""_COMPSCI401665"">2. </span><span id=""_COMPSCI401666"">Explain fundamental programming language concepts such as values and types, variables and lifetime, bindings and scope, procedural abstraction, data abstraction, and generic abstraction;</span></p><p id=""_COMPSCI401667""><span id=""_COMPSCI401668"">3. </span><span id=""_COMPSCI401669"">Explain the distinction between syntax and semantics, and read and write syntactic specifications of programming languages;</span></p><p id=""_COMPSCI401670""><span id=""_COMPSCI401671"">4. </span><span id=""_COMPSCI401672"">Explain the functions of compilers and interpreters, and compiler-interpreter interactions such as multi-stage compilers, interpretive compilers, and just-in-time compilers;</span></p><p id=""_COMPSCI401673""><span id=""_COMPSCI401674"">5. </span><span id=""_COMPSCI401675"">Implement a compiler and interpreter for a very simple programming language using compiler-generation tools.</span></p>",Programming Languages (H) COMPSCI4016,"<p id=""_COMPSCI40160""><span id=""_COMPSCI40161"">This course aims to:</span></p><p id=""_COMPSCI40162""><span id=""_COMPSCI40163"">P</span><span id=""_COMPSCI40164"">rovide a conceptual framework that will enable students to understand familiar programming languages more deeply and learn new languages more efficiently;</span></p><p id=""_COMPSCI40165""><span id=""_COMPSCI40166"">S</span><span id=""_COMPSCI40167"">how how the syntax of a programming language can be formalized;</span></p><p id=""_COMPSCI40168""><span id=""_COMPSCI40169"">E</span><span id=""_COMPSCI401610"">xplain the functions of compilers and interpreters, how they interact, and how they work;</span></p><p id=""_COMPSCI401611""><span id=""_COMPSCI401612"">S</span><span id=""_COMPSCI401613"">how how to implement a compiler using compiler-generation tools.</span></p>","<p id=""_COMPSCI401644""><span id=""_COMPSCI401645"">This course aims to:</span></p><p id=""_COMPSCI401646""><span id=""_COMPSCI401647"">P</span><span id=""_COMPSCI401648"">rovide a conceptual framework that will enable students to understand familiar programming languages more deeply and learn new languages more efficiently;</span></p><p id=""_COMPSCI401649""><span id=""_COMPSCI401650"">S</span><span id=""_COMPSCI401651"">how how the syntax of a programming language can be formalized;</span></p><p id=""_COMPSCI401652""><span id=""_COMPSCI401653"">E</span><span id=""_COMPSCI401654"">xplain the functions of compilers and interpreters, how they interact, and how they work;</span></p><p id=""_COMPSCI401655""><span id=""_COMPSCI401656"">S</span><span id=""_COMPSCI401657"">how how to implement a compiler using compiler-generation tools.</span></p>","<p id=""_COMPSCI401659""><span id=""_COMPSCI401660"">By the end of the course students will be able to:</span></p><p id=""_COMPSCI401661""><span id=""_COMPSCI401662"">1. </span><span id=""_COMPSCI401663"">Describe the relationships between the imperative, object-oriented, and functional programming paradigms;</span></p><p id=""_COMPSCI401664""><span id=""_COMPSCI401665"">2. </span><span id=""_COMPSCI401666"">Explain fundamental programming language concepts such as values and types, variables and lifetime, bindings and scope, procedural abstraction, data abstraction, and generic abstraction;</span></p><p id=""_COMPSCI401667""><span id=""_COMPSCI401668"">3. </span><span id=""_COMPSCI401669"">Explain the distinction between syntax and semantics, and read and write syntactic specifications of programming languages;</span></p><p id=""_COMPSCI401670""><span id=""_COMPSCI401671"">4. </span><span id=""_COMPSCI401672"">Explain the functions of compilers and interpreters, and compiler-interpreter interactions such as multi-stage compilers, interpretive compilers, and just-in-time compilers;</span></p><p id=""_COMPSCI401673""><span id=""_COMPSCI401674"">5. </span><span id=""_COMPSCI401675"">Implement a compiler and interpreter for a very simple programming language using compiler-generation tools.</span></p>"
103,Glasgow_Scotland,COMPSCI4077,"<h2>Glasgow_Scotland COMPSCI4077</h2><h2>title</h2>Web Science (H) COMPSCI4077<h2>summary</h2><p id=""_COMPSCI40770""><span id=""_COMPSCI40771"">Web Science is the study of the World Wide Web (WWW), its components, facets and characteristics and the impact it has on both society and technology. The World Wide Web changed the way in which we create information, communicate and interact. New models of social networks (LinkedIn, Facebook, etc.) create opportunities, which were not </span><span id=""_COMPSCI40772"">available</span><span id=""_COMPSCI40773"">&nbsp;before. Exploiting such data and networks for the benefit of individuals and organizations has become a key in our knowledge society.</span></p><h2>content</h2><p id=""_COMPSCI407717""><span id=""_COMPSCI407718"">The objective of </span><span id=""_COMPSCI407719"">this course</span><span id=""_COMPSCI407720"">&nbsp;is to </span><span id=""_COMPSCI407721"">introduce students to the field of web science and critically examine methodologies and techniques used in the field.</span></p><h2>ilo</h2><p id=""_COMPSCI407727""><span id=""_COMPSCI407728"">By the end of this course students will be able to:</span></p><p id=""_COMPSCI407729""><span id=""_COMPSCI407730"">1. </span><span id=""_COMPSCI407731"">Skills to analyse and implement technical solutions on social web applications</span></p><p id=""_COMPSCI407732""><span id=""_COMPSCI407733"">2. </span><span id=""_COMPSCI407734"">Describe the techniques employed in developing advertising models on the web</span></p><p id=""_COMPSCI407735""><span id=""_COMPSCI407736"">3. </span><span id=""_COMPSCI407737"">Describe the techniques needed to analyse social networks</span></p><p id=""_COMPSCI407738""><span id=""_COMPSCI407739"">4. </span><span id=""_COMPSCI407740"">Ability to understand and rationalise privacy threats and mitigation strategies in online communities</span></p><p id=""_COMPSCI407741""><span id=""_COMPSCI407742"">5. </span><span id=""_COMPSCI407743"">Describe</span><span id=""_COMPSCI407744"">&nbsp;methodologies to conduct large scale data analysis</span><span id=""_COMPSCI407745"">&nbsp;to analyse user behaviour on the web,</span><span id=""_COMPSCI407746"">&nbsp;to predict user demographics and purchase behaviours</span></p><p id=""_COMPSCI407747""><span id=""_COMPSCI407748"">6. </span><span id=""_COMPSCI407749"">Describe</span><span id=""_COMPSCI407750"">&nbsp;sentiment and emotion extraction techniques</span><span id=""_COMPSCI407751"">&nbsp;and employ them.</span></p>",Web Science (H) COMPSCI4077,"<p id=""_COMPSCI40770""><span id=""_COMPSCI40771"">Web Science is the study of the World Wide Web (WWW), its components, facets and characteristics and the impact it has on both society and technology. The World Wide Web changed the way in which we create information, communicate and interact. New models of social networks (LinkedIn, Facebook, etc.) create opportunities, which were not </span><span id=""_COMPSCI40772"">available</span><span id=""_COMPSCI40773"">&nbsp;before. Exploiting such data and networks for the benefit of individuals and organizations has become a key in our knowledge society.</span></p>","<p id=""_COMPSCI407717""><span id=""_COMPSCI407718"">The objective of </span><span id=""_COMPSCI407719"">this course</span><span id=""_COMPSCI407720"">&nbsp;is to </span><span id=""_COMPSCI407721"">introduce students to the field of web science and critically examine methodologies and techniques used in the field.</span></p>","<p id=""_COMPSCI407727""><span id=""_COMPSCI407728"">By the end of this course students will be able to:</span></p><p id=""_COMPSCI407729""><span id=""_COMPSCI407730"">1. </span><span id=""_COMPSCI407731"">Skills to analyse and implement technical solutions on social web applications</span></p><p id=""_COMPSCI407732""><span id=""_COMPSCI407733"">2. </span><span id=""_COMPSCI407734"">Describe the techniques employed in developing advertising models on the web</span></p><p id=""_COMPSCI407735""><span id=""_COMPSCI407736"">3. </span><span id=""_COMPSCI407737"">Describe the techniques needed to analyse social networks</span></p><p id=""_COMPSCI407738""><span id=""_COMPSCI407739"">4. </span><span id=""_COMPSCI407740"">Ability to understand and rationalise privacy threats and mitigation strategies in online communities</span></p><p id=""_COMPSCI407741""><span id=""_COMPSCI407742"">5. </span><span id=""_COMPSCI407743"">Describe</span><span id=""_COMPSCI407744"">&nbsp;methodologies to conduct large scale data analysis</span><span id=""_COMPSCI407745"">&nbsp;to analyse user behaviour on the web,</span><span id=""_COMPSCI407746"">&nbsp;to predict user demographics and purchase behaviours</span></p><p id=""_COMPSCI407747""><span id=""_COMPSCI407748"">6. </span><span id=""_COMPSCI407749"">Describe</span><span id=""_COMPSCI407750"">&nbsp;sentiment and emotion extraction techniques</span><span id=""_COMPSCI407751"">&nbsp;and employ them.</span></p>"
128,CAU_Germany,inf-AuLearn,"<h2>CAU_Germany inf-AuLearn</h2><h2>title</h2>Autonomous Learning<h2>summary</h2>Autonomous Learning research aims at understanding how autonomous systems can efficiently learn from the interaction with the environment, especially by having an integrated approach to decision making and learning, allowing systems to autonomously decide on actions, representations, hyper-parameters and model structures for the purpose of efficient learning. The term ""autonomous"" refers to the ability of the system to learn without or with only very limited external support, which includes manual intervention of humans, availability of pre-defined models or expert knowledge, and availability of large sets of sample data. Specific research topics are: Adaptation of the learning models / techniques based on observations, learning from interaction with the environment, re-using knowledge from one domain in another domain, detection of behaviour that deviates from 'usual' or expected behaviour, and learning from and with other systems of the same kind. The lecture gives an introduction to the field of autonomous learning with a particular focus on a utilisation of the different techniques within intelligent systems. Autonomous Learning is cutting edge research, which means that parts of the lecture are based on current research articles rather than on textbooks. Furthermore, a practitioner's perspective is combined with theoretical understanding of the concepts: the lecture units are combined with traditional exercises but also with practical tasks that have to be solved by making use of techniques discussed in the lecture.<h2>content</h2>
a) Introduction and organisation

b) Machine learning basics

c) Reinforcement Learning

d) Anomaly/Novelty Detection

e) Active Learning

Further (depending on time and scope), the following topics may be covered as well:

f) Transfer Learning

g) Model selection (hyper-parameter optimisation and evaluation)

h) Collaborative Learning

i) Summary and outlook (incl. meta-learning)<h2>ilo</h2>
The overall goal of the course is to derive a basic understanding of the motivation, the general concept, and particularly important methods covering the most prominent parts of the field of autonomous learning. This includes techniques for the following aspects of machine learning:

Fully autonomous learning behaviour: hyper-parameter optimisation, transfer learning, (self-)evaluation,
self-awareness or environment-awareness with a major focus on anomaly/novelty detection
By interaction with the environment via sensors and actuators: reinforcement learning
By efficiently integrating humans into the learning process: active learning
By interacting with other intelligent systems: collaborative learning
By using all the above: meta-learning
Particular goals are:

a) Knowledge / Skills:

Understanding of methods for achieving ""intelligence"" in technical systems, control of learning behaviour with minimal user interaction, continuous self-improvement of system behaviour, cooperation in learning between distributed technical systems

b) Abilities:

Selection and application of techniques of machine learning in technical systems under real-world conditions to control autonomous system behaviour

c) Competencies:

Ability to analyse autonomous learning processes and their behaviour, to determine and interpret relevant assessment parameters / Competence to plan, design and develop intelligent technical systems with the ability to learn autonomously
",Autonomous Learning,"Autonomous Learning research aims at understanding how autonomous systems can efficiently learn from the interaction with the environment, especially by having an integrated approach to decision making and learning, allowing systems to autonomously decide on actions, representations, hyper-parameters and model structures for the purpose of efficient learning. The term ""autonomous"" refers to the ability of the system to learn without or with only very limited external support, which includes manual intervention of humans, availability of pre-defined models or expert knowledge, and availability of large sets of sample data. Specific research topics are: Adaptation of the learning models / techniques based on observations, learning from interaction with the environment, re-using knowledge from one domain in another domain, detection of behaviour that deviates from 'usual' or expected behaviour, and learning from and with other systems of the same kind. The lecture gives an introduction to the field of autonomous learning with a particular focus on a utilisation of the different techniques within intelligent systems. Autonomous Learning is cutting edge research, which means that parts of the lecture are based on current research articles rather than on textbooks. Furthermore, a practitioner's perspective is combined with theoretical understanding of the concepts: the lecture units are combined with traditional exercises but also with practical tasks that have to be solved by making use of techniques discussed in the lecture.","
a) Introduction and organisation

b) Machine learning basics

c) Reinforcement Learning

d) Anomaly/Novelty Detection

e) Active Learning

Further (depending on time and scope), the following topics may be covered as well:

f) Transfer Learning

g) Model selection (hyper-parameter optimisation and evaluation)

h) Collaborative Learning

i) Summary and outlook (incl. meta-learning)","
The overall goal of the course is to derive a basic understanding of the motivation, the general concept, and particularly important methods covering the most prominent parts of the field of autonomous learning. This includes techniques for the following aspects of machine learning:

Fully autonomous learning behaviour: hyper-parameter optimisation, transfer learning, (self-)evaluation,
self-awareness or environment-awareness with a major focus on anomaly/novelty detection
By interaction with the environment via sensors and actuators: reinforcement learning
By efficiently integrating humans into the learning process: active learning
By interacting with other intelligent systems: collaborative learning
By using all the above: meta-learning
Particular goals are:

a) Knowledge / Skills:

Understanding of methods for achieving ""intelligence"" in technical systems, control of learning behaviour with minimal user interaction, continuous self-improvement of system behaviour, cooperation in learning between distributed technical systems

b) Abilities:

Selection and application of techniques of machine learning in technical systems under real-world conditions to control autonomous system behaviour

c) Competencies:

Ability to analyse autonomous learning processes and their behaviour, to determine and interpret relevant assessment parameters / Competence to plan, design and develop intelligent technical systems with the ability to learn autonomously
"
134,CAU_Germany,inf-EERP,"<h2>CAU_Germany inf-EERP</h2><h2>title</h2>Implementation of ERP systems
<h2>summary</h2>The core task of ERP systems is the volume and value-related planning, recording and settlement of all essential business transactions of a company. ERP systems are therefore one of the central components of the IT landscape of larger companies today. Accordingly, new introductions or changes of these systems in larger companies are often highly complex and thus complex and expensive large-scale IT projects.

The high value of such software for companies can also be seen from the fact that the group with the currently largest market capitalization within the German stock index DAX® is neither a car manufacturer nor a classic industrial group, but a provider of corresponding business software. In this module, using the example of its ERP system (a) the knowledge about the support of operational processes by standard software is further deepened, (b) shows with which project management procedures and methods corresponding large-scale IT projects are carried out in practice, and (c) shows how an entire ecosystem can be formed around such a software product.<h2>content</h2>Overview of standard operational software using the example of the product portfolio of SAP SE from a business point of view (ERP, analytics, business networks) and from a technical point of view (database, application, user interface, data integration, artificial intelligence)
Mapping of common, operational processes in ERP standard software (stainable data, quantity and value flows)
Procedures for the introduction and conversion of standard operational software using the example of large introductions of SAP® ERP software (classic, SAP® Activate/Focus Build, global rollout strategies) and organization of corresponding projects (ecosystem, project management processes)
Strategies for the further development of standard operational software in the company (governance structures and processes)
Trends (current situation in companies, technological innovations)<h2>ilo</h2>The students;

have an in-depth understanding of the range of applications of standard operational software
have an idea of the objectives, tasks and challenges of the introduction or Conversion of standard operational software
know the usual procedures for large-scale IT projects","Implementation of ERP systems
","The core task of ERP systems is the volume and value-related planning, recording and settlement of all essential business transactions of a company. ERP systems are therefore one of the central components of the IT landscape of larger companies today. Accordingly, new introductions or changes of these systems in larger companies are often highly complex and thus complex and expensive large-scale IT projects.

The high value of such software for companies can also be seen from the fact that the group with the currently largest market capitalization within the German stock index DAX® is neither a car manufacturer nor a classic industrial group, but a provider of corresponding business software. In this module, using the example of its ERP system (a) the knowledge about the support of operational processes by standard software is further deepened, (b) shows with which project management procedures and methods corresponding large-scale IT projects are carried out in practice, and (c) shows how an entire ecosystem can be formed around such a software product.","Overview of standard operational software using the example of the product portfolio of SAP SE from a business point of view (ERP, analytics, business networks) and from a technical point of view (database, application, user interface, data integration, artificial intelligence)
Mapping of common, operational processes in ERP standard software (stainable data, quantity and value flows)
Procedures for the introduction and conversion of standard operational software using the example of large introductions of SAP® ERP software (classic, SAP® Activate/Focus Build, global rollout strategies) and organization of corresponding projects (ecosystem, project management processes)
Strategies for the further development of standard operational software in the company (governance structures and processes)
Trends (current situation in companies, technological innovations)","The students;

have an in-depth understanding of the range of applications of standard operational software
have an idea of the objectives, tasks and challenges of the introduction or Conversion of standard operational software
know the usual procedures for large-scale IT projects"
136,Kennesaw_USA,IT4123,"<h2>Kennesaw_USA IT4123</h2><h2>title</h2>Electronic Commerce<h2>summary</h2>This course will examine the aspects of electronic commerce. Topics include internet development, EDS, security, network connectivity and privacy. Basic business practices using electronic commerce will also be covered.<h2>ilo</h2>1. Analyze the needs of a business in relation to what requirements are needed to support the functions of the company for an e-commerce business plan.
2. Describe the business models of e-commerce, including the process of e-commerce payment systems, e-commerce marketing concepts and e-commerce site preparation.
3. Design and build a working e-commerce web-site prototype.
4. Describe the basic parts of security for an e-commerce site, including how encryption works.
5. Discuss and debate the pros and cons of the supply chain management model, and how new digital media support e-commerce.
6. Understand the e-commerce concepts of auctions, portals and on-line communities, and describe the ethical, social and political issues of e-commerce.",Electronic Commerce,"This course will examine the aspects of electronic commerce. Topics include internet development, EDS, security, network connectivity and privacy. Basic business practices using electronic commerce will also be covered.",,"1. Analyze the needs of a business in relation to what requirements are needed to support the functions of the company for an e-commerce business plan.
2. Describe the business models of e-commerce, including the process of e-commerce payment systems, e-commerce marketing concepts and e-commerce site preparation.
3. Design and build a working e-commerce web-site prototype.
4. Describe the basic parts of security for an e-commerce site, including how encryption works.
5. Discuss and debate the pros and cons of the supply chain management model, and how new digital media support e-commerce.
6. Understand the e-commerce concepts of auctions, portals and on-line communities, and describe the ethical, social and political issues of e-commerce."
137,Kennesaw_USA,IT4213,"<h2>Kennesaw_USA IT4213</h2><h2>title</h2>Mobile Web Development<h2>summary</h2>This course introduces the concepts, practices, and technologies to design, develop, and manage cross-platform web sites and applications running on modern mobile devices.<h2>ilo</h2>1. Compare and contrast user interactions with web sites and applications delivered as desktop web, mobile web, and mobile application.
2. Apply appropriate mobile user interface design principles and techniques to create responsive and touch friendly web user interfaces.
3. Use latest web technologies and programming languages to create cross platform web sites and applications.
4. Identify and use the appropriate development technologies, tools, and frameworks for mobile web development.",Mobile Web Development,"This course introduces the concepts, practices, and technologies to design, develop, and manage cross-platform web sites and applications running on modern mobile devices.",,"1. Compare and contrast user interactions with web sites and applications delivered as desktop web, mobile web, and mobile application.
2. Apply appropriate mobile user interface design principles and techniques to create responsive and touch friendly web user interfaces.
3. Use latest web technologies and programming languages to create cross platform web sites and applications.
4. Identify and use the appropriate development technologies, tools, and frameworks for mobile web development."
138,Kennesaw_USA,IT4203,"<h2>Kennesaw_USA IT4203</h2><h2>title</h2>Advanced Web Development<h2>summary</h2>This course covers more advanced topics on web site design and development including server pages, programming, database integration, and web server systems and security administration.<h2>ilo</h2>1. Demonstrate use of advanced JavaScript features, including anonymous functions and closures
2. Demonstrate use of advanced CSS features, including CSS 3 and responsive web pages
3. Use Ajax to update pages with server data without reloading
4. Use the features of HTML 5
5. Demonstrate effective use of the jQuery framework.",Advanced Web Development,"This course covers more advanced topics on web site design and development including server pages, programming, database integration, and web server systems and security administration.",,"1. Demonstrate use of advanced JavaScript features, including anonymous functions and closures
2. Demonstrate use of advanced CSS features, including CSS 3 and responsive web pages
3. Use Ajax to update pages with server data without reloading
4. Use the features of HTML 5
5. Demonstrate effective use of the jQuery framework."
139,Kennesaw_USA,CGDD4113,"<h2>Kennesaw_USA CGDD4113</h2><h2>title</h2>3D Modeling and Animation<h2>summary</h2>This course explores the theory and application of 3D geometric model generation and animation. Topics include mesh and Non-uniform Rational B-Spline (NURB) modeling, textures, subdivision and levels of model detail, rigid/constrained body dynamics, and non-rigid/fluid dynamics. Students will be required to develop and animate a complex model, and a significant project is required <h2>ilo</h2>1. Describe the mathematics of 3D modeling and animation
2. Apply 3D modeling animation in generating a complex rendered scene
3. Utilize modern applications that streamline the modeling and animation process
4. Discuss the complexity of modeling and animation and trade-offs between fidelity and performance",3D Modeling and Animation,"This course explores the theory and application of 3D geometric model generation and animation. Topics include mesh and Non-uniform Rational B-Spline (NURB) modeling, textures, subdivision and levels of model detail, rigid/constrained body dynamics, and non-rigid/fluid dynamics. Students will be required to develop and animate a complex model, and a significant project is required ",,"1. Describe the mathematics of 3D modeling and animation
2. Apply 3D modeling animation in generating a complex rendered scene
3. Utilize modern applications that streamline the modeling and animation process
4. Discuss the complexity of modeling and animation and trade-offs between fidelity and performance"
149,Kennesaw_USA,CS4522,"<h2>Kennesaw_USA CS4522</h2><h2>title</h2>HPC & Parallel Programming<h2>summary</h2>This course will introduce parallel programming techniques for shared memory and distributed memory systems. Topics include threading, OpenMP, and MPI. <h2>ilo</h2>1. Discuss the different processor and memory configurations used in HPC
2. Implement programs for shared memory environments using OpenMP
3. Implement programs for distributed memory environments using MPI",HPC & Parallel Programming,"This course will introduce parallel programming techniques for shared memory and distributed memory systems. Topics include threading, OpenMP, and MPI. ",,"1. Discuss the different processor and memory configurations used in HPC
2. Implement programs for shared memory environments using OpenMP
3. Implement programs for distributed memory environments using MPI"
154,Kennesaw_USA,CS4712,"<h2>Kennesaw_USA CS4712</h2><h2>title</h2>User Interface Engineering<h2>summary</h2>A comprehensive study of techniques in design and implementation of user interfaces engineering. Topics include the foundation of human-computer interaction and interface related to software lifecycle, building a graphic user interface engineering, interaction devices and technologies, human-computer dialogue, cognitive models, usability, the design and development process, user interface management systems (UIMS), interface style and techniques, user learning, and diversity in interaction styles. Major research and the building of a working graphic user interface are included. <h2>ilo</h2>1. Describe basic user interface engineering definitions, concepts, and principles.
2. Apply user interface concepts and principles to analyze and evaluate a variety of approaches to user interface design.
3. Acquire an understanding of needs analysis of user interactions/interfaces, legal, ethical, and social issues.
4. Design, develop, implement, and present a new user interface for an application applying concepts and principles of user interface.",User Interface Engineering,"A comprehensive study of techniques in design and implementation of user interfaces engineering. Topics include the foundation of human-computer interaction and interface related to software lifecycle, building a graphic user interface engineering, interaction devices and technologies, human-computer dialogue, cognitive models, usability, the design and development process, user interface management systems (UIMS), interface style and techniques, user learning, and diversity in interaction styles. Major research and the building of a working graphic user interface are included. ",,"1. Describe basic user interface engineering definitions, concepts, and principles.
2. Apply user interface concepts and principles to analyze and evaluate a variety of approaches to user interface design.
3. Acquire an understanding of needs analysis of user interactions/interfaces, legal, ethical, and social issues.
4. Design, develop, implement, and present a new user interface for an application applying concepts and principles of user interface."
158,Kennesaw_USA,CSE1300,"<h2>Kennesaw_USA CSE1300</h2><h2>title</h2>Introduction to Computing Principles<h2>summary</h2>This course is an introductory computing principles course. Instruction centers on an overview of the history, scope, and impact of computing as well as critical, algorithmic and computational thinking on problem decomposition and fundamental programming concepts. <h2>ilo</h2>1. Synthesize how software has influenced innovations in other fields and helped people organizations and society to solve problems
2. Use computational thinking to ask questions and find different ways to solve problems
3. Design a solution to a program as an algorithm and convert the algorithm into a procedural program
4. Objective 4 -Describe the differences between computing disciplines and identify possible job opportunities in the computing field",Introduction to Computing Principles,"This course is an introductory computing principles course. Instruction centers on an overview of the history, scope, and impact of computing as well as critical, algorithmic and computational thinking on problem decomposition and fundamental programming concepts. ",,"1. Synthesize how software has influenced innovations in other fields and helped people organizations and society to solve problems
2. Use computational thinking to ask questions and find different ways to solve problems
3. Design a solution to a program as an algorithm and convert the algorithm into a procedural program
4. Objective 4 -Describe the differences between computing disciplines and identify possible job opportunities in the computing field"
159,Kennesaw_USA,CSE3203,"<h2>Kennesaw_USA CSE3203</h2><h2>title</h2>Overview of Mobile Systems<h2>summary</h2>This course explores the use and issues of mobile applications in business including information security issues, connecting to cloud computing services, and mobile interface and programming. A significant design or development project will be created in the course. <h2>ilo</h2>1. Review basic elements of a mobile ecosystem
2. Explain major technical features of mobile systems including connectivity hardware and software
3. Compare major mobile app development approaches platforms and tools
4. Discuss relevant mobile app development issues including user experience and security
5. Develop native mobile apps",Overview of Mobile Systems,"This course explores the use and issues of mobile applications in business including information security issues, connecting to cloud computing services, and mobile interface and programming. A significant design or development project will be created in the course. ",,"1. Review basic elements of a mobile ecosystem
2. Explain major technical features of mobile systems including connectivity hardware and software
3. Compare major mobile app development approaches platforms and tools
4. Discuss relevant mobile app development issues including user experience and security
5. Develop native mobile apps"
160,Kennesaw_USA,CSE4983,"<h2>Kennesaw_USA CSE4983</h2><h2>title</h2>CSE Computing Internship<h2>summary</h2>This course helps students gain practical experience through real-world projects and professional work. Students will demonstrate an ability to apply computing principles and technologies relevant to their major in a specific real-world project jointly supervised by an industry mentor and a faculty advisor. Students will work in a project team in an enterprise environment demonstrating ethical behavior as a computing professional, an understanding of social, professional and ethical issues related to computing, and an ability to integrate the knowledge acquired in preceding courses. Communication skills and leadership are also evaluated as well as professional computing skills and knowledge. 150+ hours per semester required at an internship site. The course can not be repeated for credit. <h2>ilo</h2>1. Demonstrate an ability to apply computing principles and technologies relevant to their major in a specific real-world project.
2. Demonstrate an ability to work effectively in teams in a working environment.
3. Demonstrate ethical behavior as a computing professional and an understanding of social, professional and ethical issues related to computing.
4. Demonstrate both written and oral communication skills appropriate to the major to convey the tasks and accomplishments related to the internship assignment.
5. Display the skills and knowledge to be employable in positions that utilize computing principles and technologies.
6. Evaluate the skills and knowledge learned in the classroom in relation to the skills and knowledge required to complete the internship.",CSE Computing Internship,"This course helps students gain practical experience through real-world projects and professional work. Students will demonstrate an ability to apply computing principles and technologies relevant to their major in a specific real-world project jointly supervised by an industry mentor and a faculty advisor. Students will work in a project team in an enterprise environment demonstrating ethical behavior as a computing professional, an understanding of social, professional and ethical issues related to computing, and an ability to integrate the knowledge acquired in preceding courses. Communication skills and leadership are also evaluated as well as professional computing skills and knowledge. 150+ hours per semester required at an internship site. The course can not be repeated for credit. ",,"1. Demonstrate an ability to apply computing principles and technologies relevant to their major in a specific real-world project.
2. Demonstrate an ability to work effectively in teams in a working environment.
3. Demonstrate ethical behavior as a computing professional and an understanding of social, professional and ethical issues related to computing.
4. Demonstrate both written and oral communication skills appropriate to the major to convey the tasks and accomplishments related to the internship assignment.
5. Display the skills and knowledge to be employable in positions that utilize computing principles and technologies.
6. Evaluate the skills and knowledge learned in the classroom in relation to the skills and knowledge required to complete the internship."
163,Kennesaw_USA,CYBR3223,"<h2>Kennesaw_USA CYBR3223</h2><h2>title</h2>Software Acquisition and Project Management<h2>summary</h2>The course provides a high level introduction to two areas that are crucial to the IT profession, namely project management and software acquisition. It introduces students to the phases both in the project management and software acquisition and implementation process. Since requirements are crucial to both activities, the course will provide students with an in-depth introduction to requirements engineering. The course will also introduce students to a widely used project management information system. <h2>ilo</h2>1. Discuss the elements of the basic Software Development Life Cycle and implement an analysis and design of a project using current project management tools
2. Compare and contrast the advantages and disadvantages of building vs buying a software system
3. Identify the elements and challenges of requirements engineering and project management
4. Identify the project phases and challenges of acquiring, integrating and implementing a software package
5. Evaluate a Request for Proposal for a software package",Software Acquisition and Project Management,"The course provides a high level introduction to two areas that are crucial to the IT profession, namely project management and software acquisition. It introduces students to the phases both in the project management and software acquisition and implementation process. Since requirements are crucial to both activities, the course will provide students with an in-depth introduction to requirements engineering. The course will also introduce students to a widely used project management information system. ",,"1. Discuss the elements of the basic Software Development Life Cycle and implement an analysis and design of a project using current project management tools
2. Compare and contrast the advantages and disadvantages of building vs buying a software system
3. Identify the elements and challenges of requirements engineering and project management
4. Identify the project phases and challenges of acquiring, integrating and implementing a software package
5. Evaluate a Request for Proposal for a software package"
176,Kennesaw_USA,IT3503,"<h2>Kennesaw_USA IT3503</h2><h2>title</h2>Foundations of Health Information Technology<h2>summary</h2>This course introduces students to the field of health information technology (HIT). Students will become familiar with the content, use, and structure of the health care data and medical records, health information management, the fundamentals of healthcare workflow and process analysis and redesign as a necessary component of complete practice automation, and health information systems. Students will also become familiar with the health care delivery systems in the U.S. and IT organizations and resources. <h2>ilo</h2>1. Describe the healthcare delivery systems and different healthcare settings in the U.S. and the reimbursement methodologies utilized in healthcare organizations
2. Describe the factors that had led to a need for health information technology and Electronic Health Record systems
3. Provide examples of different types of health information technology used in the healthcare organizations
4. Explain the importance of health data management and performance improvement activities in the healthcare environment
5. Identify the effect the ethical and legal issues on health information technology
6. Explain HIPAA and HITECH regulations and analyze ways to maintain the privacy and security of protected health information
7. Recognize the future of health information technology in order to be an organizational resource in this topic area",Foundations of Health Information Technology,"This course introduces students to the field of health information technology (HIT). Students will become familiar with the content, use, and structure of the health care data and medical records, health information management, the fundamentals of healthcare workflow and process analysis and redesign as a necessary component of complete practice automation, and health information systems. Students will also become familiar with the health care delivery systems in the U.S. and IT organizations and resources. ",,"1. Describe the healthcare delivery systems and different healthcare settings in the U.S. and the reimbursement methodologies utilized in healthcare organizations
2. Describe the factors that had led to a need for health information technology and Electronic Health Record systems
3. Provide examples of different types of health information technology used in the healthcare organizations
4. Explain the importance of health data management and performance improvement activities in the healthcare environment
5. Identify the effect the ethical and legal issues on health information technology
6. Explain HIPAA and HITECH regulations and analyze ways to maintain the privacy and security of protected health information
7. Recognize the future of health information technology in order to be an organizational resource in this topic area"
181,Kennesaw_USA,IT4423,"<h2>Kennesaw_USA IT4423</h2><h2>title</h2>Linux/Unix Administration<h2>summary</h2>This course introduces Linux/Unix operating systems. Topics include system administration, file systems and access permissions, regular expression, common tools and utilities, and network service configurations. Lessons will be enhanced using hands-on exercises. <h2>ilo</h2>1. Describe concepts and structure of the Linux/Unix operating system
2. Use common commands and utilities for general file system operations
3. Write shell scripts for common shell environment
4. Perform system administration tasks to manage files, software, storage, users, processes and services
5. Configure TCP/IP networking and common network/internet services and clients such as SSH, FTP, Web
6. Install critical software on Linux, such as Apache, MySQL, and Python  LAMP",Linux/Unix Administration,"This course introduces Linux/Unix operating systems. Topics include system administration, file systems and access permissions, regular expression, common tools and utilities, and network service configurations. Lessons will be enhanced using hands-on exercises. ",,"1. Describe concepts and structure of the Linux/Unix operating system
2. Use common commands and utilities for general file system operations
3. Write shell scripts for common shell environment
4. Perform system administration tasks to manage files, software, storage, users, processes and services
5. Configure TCP/IP networking and common network/internet services and clients such as SSH, FTP, Web
6. Install critical software on Linux, such as Apache, MySQL, and Python  LAMP"
196,Kennesaw_USA,IT4893,"<h2>Kennesaw_USA IT4893</h2><h2>title</h2>Internet of Things: Applications and Security<h2>summary</h2>This course introduces core knowledge and skills required to develop and design innovative IoT solutions. Students will analyze the challenges, apply appropriate patterns for user-interaction and learn about trends and characteristics in IoT. In addition, students will evaluate the security design of a suite of IoT-connected products. <h2>ilo</h2>1. Define the meaning of internet of things in various IoT application domains  smart cities, smart environment, eHealth, etc.
2. Illustrate the impact of IoT on existing business models and business use cases
3. Explain the IoT in conjunction with big data, applications, and mobility
4. Illustrate IoT security challenges and the impact of IoT on consumer privacy
5. Define the components required for the internet of things
6. Design and develop a smart device",Internet of Things: Applications and Security,"This course introduces core knowledge and skills required to develop and design innovative IoT solutions. Students will analyze the challenges, apply appropriate patterns for user-interaction and learn about trends and characteristics in IoT. In addition, students will evaluate the security design of a suite of IoT-connected products. ",,"1. Define the meaning of internet of things in various IoT application domains  smart cities, smart environment, eHealth, etc.
2. Illustrate the impact of IoT on existing business models and business use cases
3. Explain the IoT in conjunction with big data, applications, and mobility
4. Illustrate IoT security challenges and the impact of IoT on consumer privacy
5. Define the components required for the internet of things
6. Design and develop a smart device"
197,Kennesaw_USA,SWE3683,"<h2>Kennesaw_USA SWE3683</h2><h2>title</h2>Embedded Systems Analysis and Design<h2>summary</h2>The analysis and design course focuses on using modern methods, techniques, and tools for specification and design of embedded systems. Topics include analytical methods such as RMA, development methods such as HOOD, and notations like UML, Petri-nets, etc. are covered. Performance evaluation based on modeling and simulation techniques is also covered. This is a project based course. <h2>ilo</h2>1. Understand the importance of embedded systems, the challenges involved, and systematic approaches to building such systems.
2. Explain and implement fundamental principles and methodologies of embedded software development effectively utilizing current OOAD methodologies.
3. Appreciate engineering issues in the development of embedded software, such as user concerns, maintainability, dependability and safety, and division of labor.
4. Analyze a software development problem, express it succinctly and precisely, design module structures to solve a problem, and evaluate alternatives.
5. Implement a module so that it executes efficiently and correctly.
6. Work in a small team on an embedded systems project of significant scale and scope.
7. Apply knowledge about software requirements, design, construction, project management, and quality to an embedded systems project.
8. Effectively use embedded operating systems, CASE tools, languages, etc.
9. Understand the scope, roles, uses, and development trends of the most widely used embedded software engineering standards.",Embedded Systems Analysis and Design,"The analysis and design course focuses on using modern methods, techniques, and tools for specification and design of embedded systems. Topics include analytical methods such as RMA, development methods such as HOOD, and notations like UML, Petri-nets, etc. are covered. Performance evaluation based on modeling and simulation techniques is also covered. This is a project based course. ",,"1. Understand the importance of embedded systems, the challenges involved, and systematic approaches to building such systems.
2. Explain and implement fundamental principles and methodologies of embedded software development effectively utilizing current OOAD methodologies.
3. Appreciate engineering issues in the development of embedded software, such as user concerns, maintainability, dependability and safety, and division of labor.
4. Analyze a software development problem, express it succinctly and precisely, design module structures to solve a problem, and evaluate alternatives.
5. Implement a module so that it executes efficiently and correctly.
6. Work in a small team on an embedded systems project of significant scale and scope.
7. Apply knowledge about software requirements, design, construction, project management, and quality to an embedded systems project.
8. Effectively use embedded operating systems, CASE tools, languages, etc.
9. Understand the scope, roles, uses, and development trends of the most widely used embedded software engineering standards."
198,Kennesaw_USA,SWE4633,"<h2>Kennesaw_USA SWE4633</h2><h2>title</h2>Cloud Software Development<h2>summary</h2>This course discusses the fundamental concepts and tools of cloud-based application development. Students will learn how to develop apps on top of the cloud with an understanding of various contemporary cloud providers (e.g., Amazon Web Services, Google Cloud, or Microsoft Azure). Students will do hands-on projects focused on building cloud-run applications using their platform of choice. <h2>ilo</h2>1. Describe an apply principles of cloud-based application development
2. Describe service models in cloud computing
3. Describe and apply the principles of Cloud Web Services and its related technologies
4. Design and develop applications in the cloud",Cloud Software Development,"This course discusses the fundamental concepts and tools of cloud-based application development. Students will learn how to develop apps on top of the cloud with an understanding of various contemporary cloud providers (e.g., Amazon Web Services, Google Cloud, or Microsoft Azure). Students will do hands-on projects focused on building cloud-run applications using their platform of choice. ",,"1. Describe an apply principles of cloud-based application development
2. Describe service models in cloud computing
3. Describe and apply the principles of Cloud Web Services and its related technologies
4. Design and develop applications in the cloud"
199,Kennesaw_USA,SWE4743,"<h2>Kennesaw_USA SWE4743</h2><h2>title</h2>Object-Oriented Development<h2>summary</h2>This course involves engineering activities related to the analysis, design, and implementation of object-oriented software systems. Topics include modeling foundations, requirements specification and documentation, design concepts and strategies, and OOAD methodologies with an emphasis on UML. The course includes a major project utilizing current analysis and design methods and tools implemented in a contemporary IDE. <h2>ilo</h2>1. Understand and be able to apply the principles of object-oriented software engineering to software analysis design and development
2. Utilize current OO design and analysis methodologies such as UML responsibility-driven design and data-driven design effectively
3. Use current software tools to effectively model specify design and develop object-oriented software systems using common OO design patterns",Object-Oriented Development,"This course involves engineering activities related to the analysis, design, and implementation of object-oriented software systems. Topics include modeling foundations, requirements specification and documentation, design concepts and strategies, and OOAD methodologies with an emphasis on UML. The course includes a major project utilizing current analysis and design methods and tools implemented in a contemporary IDE. ",,"1. Understand and be able to apply the principles of object-oriented software engineering to software analysis design and development
2. Utilize current OO design and analysis methodologies such as UML responsibility-driven design and data-driven design effectively
3. Use current software tools to effectively model specify design and develop object-oriented software systems using common OO design patterns"
200,Kennesaw_USA,SWE4783,"<h2>Kennesaw_USA SWE4783</h2><h2>title</h2>User Interaction Engineering<h2>summary</h2>This course covers the basic theories and principles applied to the design of human-computer interfaces. It introduces students to the basic concepts used in designing interactions. It will cover the basic theory and methods that exist in the field. Case studies are used throughout the readings to exemplify the methods presented and to lend a context to the issues discussed. This course will focus on the semiotic engineering approach to human-computer interaction, in which the interaction is analyzed in terms of communication between the designers of the artifact and the user. <h2>ilo</h2>1. Know and use User Interaction Engineering principles and guidelines
2. Gather the user and task characteristics to form an interaction dialogue which is evaluated by the user to be satisfactory
3. Design and build an interface system that meets the goals of the user interaction dialogue
4. Perform a user interaction evaluation",User Interaction Engineering,"This course covers the basic theories and principles applied to the design of human-computer interfaces. It introduces students to the basic concepts used in designing interactions. It will cover the basic theory and methods that exist in the field. Case studies are used throughout the readings to exemplify the methods presented and to lend a context to the issues discussed. This course will focus on the semiotic engineering approach to human-computer interaction, in which the interaction is analyzed in terms of communication between the designers of the artifact and the user. ",,"1. Know and use User Interaction Engineering principles and guidelines
2. Gather the user and task characteristics to form an interaction dialogue which is evaluated by the user to be satisfactory
3. Design and build an interface system that meets the goals of the user interaction dialogue
4. Perform a user interaction evaluation"
202,UofT_Canada,CSC301H5,<h2>UofT_Canada CSC301H5</h2><h2>title</h2>Introduction to Software Engineering<h2>content</h2>An introduction to agile development methods appropriate for medium-sized teams and rapidly-moving projects. Basic software development infrastructure; requirements elicitation and tracking; estimation and prioritization; teamwork skills; basic UML; design patterns and refactoring; security.,Introduction to Software Engineering,,An introduction to agile development methods appropriate for medium-sized teams and rapidly-moving projects. Basic software development infrastructure; requirements elicitation and tracking; estimation and prioritization; teamwork skills; basic UML; design patterns and refactoring; security.,
213,UofT_Canada,CSC488H5,"<h2>UofT_Canada CSC488H5</h2><h2>title</h2>Compilers and Interpreters<h2>content</h2>Compiler organization, compiler writing tools, use of regular expressions, finite automata and content-free grammars, scanning and parsing, runtime organization, semantic analysis, implementing the runtime model, storage allocation, code generation.",Compilers and Interpreters,,"Compiler organization, compiler writing tools, use of regular expressions, finite automata and content-free grammars, scanning and parsing, runtime organization, semantic analysis, implementing the runtime model, storage allocation, code generation.",
219,UOC_Spain,5.58,"<h2>UOC_Spain 05.580</h2><h2>title</h2>Compilers<h2>summary</h2>Compilers are essential tools for any computer scientist, responsible for translating textual information from one format or language to another. For example, they act as key players in the execution process of a program: they translate the program from the high-level language used by humans into a low-level language that can be executed on a computer (such as assembler or machine code).

This course introduces the basic structure of a compiler: the modules that make it up and how they communicate with each other. We will focus on the case of general purpose programming languages ​​and on the process of generating an executable from a high level program.

Specifically, we will see how a source program is analyzed to obtain its components and possible errors introduced by the programmer are detected. The concept of interpreter and its relationship with compilers will also be introduced. Subsequently, it will be studied how the object code is generated and optimized from the data obtained in the analysis part to improve performance. All of this will be implemented by using compiler build tools.<h2>content</h2>The subject is structured in six modules:

1. General Information

1. Languages

2. Basic notions

3. Structure of a compiler

4. Building compilers

You will see an overview of the general structure of a compiler.

2. Lexical analysis

1. General organization

2. Construction of lexical analyzers

3. Specification of a lexical analyzer

4. Error handling

5. The entry system

6. The symbol tables

The only part of the compiler that interacts with the source file will be studied, converting its characters into a sequence of lexical symbols (tokens) and eliminating everything that is not necessary for its analysis (comments, line breaks...).

3. Analysis

1. General notions

2. Top-down analysis

3. Bottom-up analysis

The phase in charge of verifying that the lexical symbols of the source program arrive in the correct order and that the specifications of the context-free grammar that defines the source language are met will be studied.

4. Semantic analysis

1. Semantic analysis

2. Intermediate code generation

The verification of the semantics of the source program, which depends on the context, will be studied, incorporating semantic attributes and actions in the productions of the grammar.

5. Synthesis phases

1. Code generation

2. Code optimization

The generation of code from the intermediate code will be studied, as well as everything to take into account to carry out an automatic translation and the final optimization phase.

6. Interpreted languages

1. Interpreters

2. The abstract stack machine

3. Construction of an interpreter

A concrete model of architecture for interpreters based on a memory in the form of a stack will be presented. The construction process of an interpreter based on this model will be studied.",Compilers,"Compilers are essential tools for any computer scientist, responsible for translating textual information from one format or language to another. For example, they act as key players in the execution process of a program: they translate the program from the high-level language used by humans into a low-level language that can be executed on a computer (such as assembler or machine code).

This course introduces the basic structure of a compiler: the modules that make it up and how they communicate with each other. We will focus on the case of general purpose programming languages ​​and on the process of generating an executable from a high level program.

Specifically, we will see how a source program is analyzed to obtain its components and possible errors introduced by the programmer are detected. The concept of interpreter and its relationship with compilers will also be introduced. Subsequently, it will be studied how the object code is generated and optimized from the data obtained in the analysis part to improve performance. All of this will be implemented by using compiler build tools.","The subject is structured in six modules:

1. General Information

1. Languages

2. Basic notions

3. Structure of a compiler

4. Building compilers

You will see an overview of the general structure of a compiler.

2. Lexical analysis

1. General organization

2. Construction of lexical analyzers

3. Specification of a lexical analyzer

4. Error handling

5. The entry system

6. The symbol tables

The only part of the compiler that interacts with the source file will be studied, converting its characters into a sequence of lexical symbols (tokens) and eliminating everything that is not necessary for its analysis (comments, line breaks...).

3. Analysis

1. General notions

2. Top-down analysis

3. Bottom-up analysis

The phase in charge of verifying that the lexical symbols of the source program arrive in the correct order and that the specifications of the context-free grammar that defines the source language are met will be studied.

4. Semantic analysis

1. Semantic analysis

2. Intermediate code generation

The verification of the semantics of the source program, which depends on the context, will be studied, incorporating semantic attributes and actions in the productions of the grammar.

5. Synthesis phases

1. Code generation

2. Code optimization

The generation of code from the intermediate code will be studied, as well as everything to take into account to carry out an automatic translation and the final optimization phase.

6. Interpreted languages

1. Interpreters

2. The abstract stack machine

3. Construction of an interpreter

A concrete model of architecture for interpreters based on a memory in the form of a stack will be presented. The construction process of an interpreter based on this model will be studied.",
224,UOC_Spain,5.587,"<h2>UOC_Spain 05.587</h2><h2>title</h2>Software engineering of components and distributed systems<h2>summary</h2>Ongoing advances in computing and telecommunications are changing the way software is developed. In particular, the relentless increase in the power of personal computers and mobile devices, the lowering of hardware costs, and the appearance of global coverage data networks have made possible an infrastructure that is especially conducive to the use of open and distributed systems. 

These changes have caused, among other things, that the traditional methods of software design and development (seen in the subjects of Engineering and Software Analysis and design with patterns) are insufficient, since, more or less implicitly, they assume that The application to be developed will be executed in a basically centralized environment. Therefore, traditional methods are unable to naturally manage the complexity of the requirements of this new type of systems. On the other hand, the aspects closest to the analysis and specification of requirements studied in the Requirements Engineering subject do not change with respect to what was seen in previous courses and, therefore, are not repeated here.

This subject serves as an introduction to software architectures as a framework for the design and development of distributed applications where the fundamentals, techniques and skills applicable to the modern definition of software architectures are studied and put into practice and knowledge is complemented. acquired in previous courses. The design of the architecture of software systems makes it possible to describe in an abstract and high-level way both the functionality of the system and many other non-functional aspects of it (distribution, reliability, security, adaptability, benefits, etc.). This system description is often defined by an architectural style, a classification of software systems into large families that follow a common structural pattern. Among the most common architectural styles for distributed systems are systems organized into microservices, multiple layers, client-server systems, or peer-to-peer systems.

Application design in terms of software microservices must be further refined to accommodate and implement it on a particular distributed software technology. These architectures can be implemented using any programming paradigm (object-oriented, structured...). In our specific case, the reference language will be Java, which allows the development of distributed applications with microservices architectures. These microservices are the ones that will be used to implement and test the architectural elements described in the system architecture.

Finally, some good practices in the development and production of software in distributed architectures are collected. Some of the key concepts are worked on when developing and putting into production, such as continuous delivery, DevOps culture, and deployment with containers.
<h2>content</h2>The subject is structured into 5 main activities, each one with its specific contents:

 

Activity 1: ""Distributed software architectures: a solution for every problem""

 

Book ""Fundamentals of Software Architecture"" (Richards & Ford): Chapter 1. Introduction.
Book ""Fundamentals of Software Architecture"" (Richards & Ford): Part I Foundations (Chapters 2 - 8)
Book ""Fundamentals of Software Architecture"" (Richards & Ford): Part II Architecture Styles (Chapters 9 - 18).
 

Activity 2: ""Hexagonal architectures and microservices design: a well-matched relationship""

 

Book ""Microservices patterns"" (Richardson): Chapter 1. Section 6: ""The Microservice architecture pattern language"".
Book ""Microservices patterns"" (Richardson): Chapter 2: ""Decomposition strategies"".
Book ""Microservices patterns"" (Richardson): Chapter 3: ""Interprocess communication in a microservice architecture""
Book ""Microservices patterns"" (Richardson): Chapter 5: ""Designing business logic in a microservice architecture"".
 

Activity 3: ""From creation to interconnection of microservices""

 

Book ""Microservices Patterns"" (Chris Richardson): Chapter 6: ""Developing business logic with event sourcing"". Introduction.
Book ""Microservices Patterns"" (Chris Richardson): Chapter 6: ""Developing business logic with event sourcing"".
Book ""Microservices patterns"" (Richardson): Chapter 7: ""Implementing queries in a microservice architecture""
Book ""Microservices patterns"" (Richardson): Chapter 8: ""External API patterns"".

Activity 4: ""Quality of distributed software: inherent, transversal and critical""

 

Book ""Microservice Patterns"" (Chris Richardson): Chapter 9. ""Testing Microservices: Part 1"". Introduction.
Book ""Microservice Patterns"" (Chris Richardson): Chapter 9. ""Testing Microservices: Part 1"".
Book ""Microservice Patterns"" (Chris Richardson): Chapter 10. ""Testing Microservices: Part 2"".
Book ""Software Architecture Fundamentals"" (Richards & Ford): Part I Fundamentals (Chapters 3 and 6).
 

Activity 5: ""DevOps, CD/CI and agile culture: good practices for distributed software development""

 

Book Microservice Patterns (Chris Richardson) Chapter 12 Implementation of microservices. Introduction.
Book Microservice Patterns (Chris Richardson) Chapter 12 Implementation of microservices.
Book ""Continuous Delivery: Reliable Software Releases Through Automated Build, Test, and Deployment (Jez Humble and Dave Farley) Part I: Chapters 1-10.
Book ""The DevOps Handbook"" (Patrick Debois, John Willis, Jez Humble & Gene Kim): Chapters 1 - 4.",Software engineering of components and distributed systems,"Ongoing advances in computing and telecommunications are changing the way software is developed. In particular, the relentless increase in the power of personal computers and mobile devices, the lowering of hardware costs, and the appearance of global coverage data networks have made possible an infrastructure that is especially conducive to the use of open and distributed systems. 

These changes have caused, among other things, that the traditional methods of software design and development (seen in the subjects of Engineering and Software Analysis and design with patterns) are insufficient, since, more or less implicitly, they assume that The application to be developed will be executed in a basically centralized environment. Therefore, traditional methods are unable to naturally manage the complexity of the requirements of this new type of systems. On the other hand, the aspects closest to the analysis and specification of requirements studied in the Requirements Engineering subject do not change with respect to what was seen in previous courses and, therefore, are not repeated here.

This subject serves as an introduction to software architectures as a framework for the design and development of distributed applications where the fundamentals, techniques and skills applicable to the modern definition of software architectures are studied and put into practice and knowledge is complemented. acquired in previous courses. The design of the architecture of software systems makes it possible to describe in an abstract and high-level way both the functionality of the system and many other non-functional aspects of it (distribution, reliability, security, adaptability, benefits, etc.). This system description is often defined by an architectural style, a classification of software systems into large families that follow a common structural pattern. Among the most common architectural styles for distributed systems are systems organized into microservices, multiple layers, client-server systems, or peer-to-peer systems.

Application design in terms of software microservices must be further refined to accommodate and implement it on a particular distributed software technology. These architectures can be implemented using any programming paradigm (object-oriented, structured...). In our specific case, the reference language will be Java, which allows the development of distributed applications with microservices architectures. These microservices are the ones that will be used to implement and test the architectural elements described in the system architecture.

Finally, some good practices in the development and production of software in distributed architectures are collected. Some of the key concepts are worked on when developing and putting into production, such as continuous delivery, DevOps culture, and deployment with containers.
","The subject is structured into 5 main activities, each one with its specific contents:

 

Activity 1: ""Distributed software architectures: a solution for every problem""

 

Book ""Fundamentals of Software Architecture"" (Richards & Ford): Chapter 1. Introduction.
Book ""Fundamentals of Software Architecture"" (Richards & Ford): Part I Foundations (Chapters 2 - 8)
Book ""Fundamentals of Software Architecture"" (Richards & Ford): Part II Architecture Styles (Chapters 9 - 18).
 

Activity 2: ""Hexagonal architectures and microservices design: a well-matched relationship""

 

Book ""Microservices patterns"" (Richardson): Chapter 1. Section 6: ""The Microservice architecture pattern language"".
Book ""Microservices patterns"" (Richardson): Chapter 2: ""Decomposition strategies"".
Book ""Microservices patterns"" (Richardson): Chapter 3: ""Interprocess communication in a microservice architecture""
Book ""Microservices patterns"" (Richardson): Chapter 5: ""Designing business logic in a microservice architecture"".
 

Activity 3: ""From creation to interconnection of microservices""

 

Book ""Microservices Patterns"" (Chris Richardson): Chapter 6: ""Developing business logic with event sourcing"". Introduction.
Book ""Microservices Patterns"" (Chris Richardson): Chapter 6: ""Developing business logic with event sourcing"".
Book ""Microservices patterns"" (Richardson): Chapter 7: ""Implementing queries in a microservice architecture""
Book ""Microservices patterns"" (Richardson): Chapter 8: ""External API patterns"".

Activity 4: ""Quality of distributed software: inherent, transversal and critical""

 

Book ""Microservice Patterns"" (Chris Richardson): Chapter 9. ""Testing Microservices: Part 1"". Introduction.
Book ""Microservice Patterns"" (Chris Richardson): Chapter 9. ""Testing Microservices: Part 1"".
Book ""Microservice Patterns"" (Chris Richardson): Chapter 10. ""Testing Microservices: Part 2"".
Book ""Software Architecture Fundamentals"" (Richards & Ford): Part I Fundamentals (Chapters 3 and 6).
 

Activity 5: ""DevOps, CD/CI and agile culture: good practices for distributed software development""

 

Book Microservice Patterns (Chris Richardson) Chapter 12 Implementation of microservices. Introduction.
Book Microservice Patterns (Chris Richardson) Chapter 12 Implementation of microservices.
Book ""Continuous Delivery: Reliable Software Releases Through Automated Build, Test, and Deployment (Jez Humble and Dave Farley) Part I: Chapters 1-10.
Book ""The DevOps Handbook"" (Patrick Debois, John Willis, Jez Humble & Gene Kim): Chapters 1 - 4.",
225,UOC_Spain,5.588,"<h2>UOC_Spain 05.588</h2><h2>title</h2>Software developement project<h2>summary</h2>The Software Development Project course has as its main objective the development of a specific software project and is based on the practical application of the knowledge and skills obtained so far in the Degree, such as Project Management, Fundamentals of Programming, Engineering of Software, Use of Databases, and specifically the technical skills that were obtained within Software Engineering of Components and Distributed Systems.

Despite the fact that the subject is based on carrying out a specific software project, the subject also covers both new theoretical aspects and others that complement the knowledge acquired up to now, such as agile software development methodologies.

The effective development of the project will be achieved through a specific agile methodology (Scrum) that iteratively covers in the form of sprints all the stages of the software life cycle, that is, the specification, design, implementation, testing, deployment and delivery of the project. product to the ""supposed"" customer. In particular, in the implementation stage, Java will be used to develop the distributed software based on a microserver architecture. In addition, other technologies will support the project, such as configuration, design, testing, continuous delivery, and containerized deployment tools. All these technologies have been seen and practiced in the previous subject of Software Engineering of Distributed Components and Systems and therefore it is assumed that the students know them.

Finally, the complexity of the project will require the specific development of skills related to collaborative work in small groups of students. The UOC will offer students a collaborative space where they can carry out communication between group members, share documentation and, in general, manage the project, with the support and supervision of the subject advisors.<h2>content</h2>Activity 1: ""Agile product development and conceptualization methodologies""

Book ""Essential Scrum: A practical guide to the most popular agile process by Kenneth S. Rubin. Chapter 1. Introduction.
Book ""Essential Scrum: A Practical Guide to the Most Popular Agile Process"" by Kenneth S. Rubin. Chapters 2-13.
Book ""The agile samurai"" by Jonathan Rasmusson. Chapters 3-5.
Book ""The agile samurai"" by Jonathan Rasmusson. Chapters 1-2, 6 and 15.
Book ""Agile Estimating and Planning"" by Mike Cohn (supplementary material).
Book ""Scrum - a pocket guide (3rd ed.)"" by Gunther Verheyen (supplementary material).
Activity: First Continuous Assessment Test (PEC1).
Activity 2: ""Product Planning""

Book ""Essential Scrum: A Practical Guide to the Most Popular Agile Process"" by Kenneth S. Rubin. Chapters 15-16.
Book ""Essential Scrum: A Practical Guide to the Most Popular Agile Process by Kenneth S. Rubin. Chapters 19-23.
Article ""The new user story backlog is a map"" by Jeff Patton. https://www.jpattonassociates.com/the-new-backlog/
Book ""User Stories Applied: For Agile Software Development"" by Kent Beck (supplementary material).
Book ""User Story Mapping"" by Jeff Patton (supplementary material).
Book ""Essential Scrum: A Practical Guide to the Most Popular Agile Process"" by Kenneth S. Rubin. Chapters 17 Envisioning (Product Planning) (Supplementary Material).
Book ""Clean Code: A Handbook of Agile Software Craftsmanship"" by Robert Martin (supplementary material).
Book ""Refactoring: Improving the Design of Existing Code"" by Martin Fowler (Supplementary Material)
Activity: First part of the Practice (PRAC1).",Software developement project,"The Software Development Project course has as its main objective the development of a specific software project and is based on the practical application of the knowledge and skills obtained so far in the Degree, such as Project Management, Fundamentals of Programming, Engineering of Software, Use of Databases, and specifically the technical skills that were obtained within Software Engineering of Components and Distributed Systems.

Despite the fact that the subject is based on carrying out a specific software project, the subject also covers both new theoretical aspects and others that complement the knowledge acquired up to now, such as agile software development methodologies.

The effective development of the project will be achieved through a specific agile methodology (Scrum) that iteratively covers in the form of sprints all the stages of the software life cycle, that is, the specification, design, implementation, testing, deployment and delivery of the project. product to the ""supposed"" customer. In particular, in the implementation stage, Java will be used to develop the distributed software based on a microserver architecture. In addition, other technologies will support the project, such as configuration, design, testing, continuous delivery, and containerized deployment tools. All these technologies have been seen and practiced in the previous subject of Software Engineering of Distributed Components and Systems and therefore it is assumed that the students know them.

Finally, the complexity of the project will require the specific development of skills related to collaborative work in small groups of students. The UOC will offer students a collaborative space where they can carry out communication between group members, share documentation and, in general, manage the project, with the support and supervision of the subject advisors.","Activity 1: ""Agile product development and conceptualization methodologies""

Book ""Essential Scrum: A practical guide to the most popular agile process by Kenneth S. Rubin. Chapter 1. Introduction.
Book ""Essential Scrum: A Practical Guide to the Most Popular Agile Process"" by Kenneth S. Rubin. Chapters 2-13.
Book ""The agile samurai"" by Jonathan Rasmusson. Chapters 3-5.
Book ""The agile samurai"" by Jonathan Rasmusson. Chapters 1-2, 6 and 15.
Book ""Agile Estimating and Planning"" by Mike Cohn (supplementary material).
Book ""Scrum - a pocket guide (3rd ed.)"" by Gunther Verheyen (supplementary material).
Activity: First Continuous Assessment Test (PEC1).
Activity 2: ""Product Planning""

Book ""Essential Scrum: A Practical Guide to the Most Popular Agile Process"" by Kenneth S. Rubin. Chapters 15-16.
Book ""Essential Scrum: A Practical Guide to the Most Popular Agile Process by Kenneth S. Rubin. Chapters 19-23.
Article ""The new user story backlog is a map"" by Jeff Patton. https://www.jpattonassociates.com/the-new-backlog/
Book ""User Stories Applied: For Agile Software Development"" by Kent Beck (supplementary material).
Book ""User Story Mapping"" by Jeff Patton (supplementary material).
Book ""Essential Scrum: A Practical Guide to the Most Popular Agile Process"" by Kenneth S. Rubin. Chapters 17 Envisioning (Product Planning) (Supplementary Material).
Book ""Clean Code: A Handbook of Agile Software Craftsmanship"" by Robert Martin (supplementary material).
Book ""Refactoring: Improving the Design of Existing Code"" by Martin Fowler (Supplementary Material)
Activity: First part of the Practice (PRAC1).",
229,UOC_Spain,5.594,"<h2>UOC_Spain 05.594</h2><h2>title</h2>Embedded systems<h2>summary</h2>Embedded systems are increasingly present in our lives. From network devices to industrial control systems, a wide range of devices make up what we know as an Embedded System. In this topic we want to give an overview of these systems. We will start from its definition and delve into its fields of application. The knowledge of the hardware components that constitute these systems will be deepened, we will know their programming models and the particularities that condition the development of applications for embedded systems.

The main objective of the course is for the student to learn the basic programming techniques of an embedded system, have a basic knowledge of the hardware architecture that composes them and acquire skills to work with this type of device.<h2>content</h2>Module 1- Introduction to embedded systems
In this module an introduction to embedded systems is made, the concept and its applications are presented and emphasis is placed on the development process of an embedded system.

Module 2 - The hardware of an embedded system
This module introduces the hardware architecture of an embedded system. The components that compose it are presented and their particularities are described. The objective of the module is that the student has an overview of the main hardware components that make up an embedded system.

Module 3 - The software and programming models of an embedded system
This module presents the most relevant programming models for the development of applications for embedded systems. Unlike what has been learned in other software development subjects, it will be seen that the efficiency and memory reduction used by the program is rewarded over its structuring and/or modularity.

Module 4- Operating systems for embedded systems
This module takes a hands-on approach to introduce the need for abstractions when operating with embedded systems. From the simplest approaches to real-time operating systems, the different ways to manage the resources of an embedded system are presented. Also in this module the peripheral controllers are worked on and their programming is deepened.

Module 5- Validation and evaluation tools for embedded systems.
This module introduces the tools available for an application developer to carry out their work and verify the developed software.",Embedded systems,"Embedded systems are increasingly present in our lives. From network devices to industrial control systems, a wide range of devices make up what we know as an Embedded System. In this topic we want to give an overview of these systems. We will start from its definition and delve into its fields of application. The knowledge of the hardware components that constitute these systems will be deepened, we will know their programming models and the particularities that condition the development of applications for embedded systems.

The main objective of the course is for the student to learn the basic programming techniques of an embedded system, have a basic knowledge of the hardware architecture that composes them and acquire skills to work with this type of device.","Module 1- Introduction to embedded systems
In this module an introduction to embedded systems is made, the concept and its applications are presented and emphasis is placed on the development process of an embedded system.

Module 2 - The hardware of an embedded system
This module introduces the hardware architecture of an embedded system. The components that compose it are presented and their particularities are described. The objective of the module is that the student has an overview of the main hardware components that make up an embedded system.

Module 3 - The software and programming models of an embedded system
This module presents the most relevant programming models for the development of applications for embedded systems. Unlike what has been learned in other software development subjects, it will be seen that the efficiency and memory reduction used by the program is rewarded over its structuring and/or modularity.

Module 4- Operating systems for embedded systems
This module takes a hands-on approach to introduce the need for abstractions when operating with embedded systems. From the simplest approaches to real-time operating systems, the different ways to manage the resources of an embedded system are presented. Also in this module the peripheral controllers are worked on and their programming is deepened.

Module 5- Validation and evaluation tools for embedded systems.
This module introduces the tools available for an application developer to carry out their work and verify the developed software.",
239,UOC_Spain,5.613,"<h2>UOC_Spain 05.613</h2><h2>title</h2>Data structures design<h2>summary</h2>In this subject the different strategies of data representation in a computer and the criteria to evaluate them are studied. Depending on the type of treatment that has to be done with this information (size, access criteria, etc.), it will be possible to select the strategy that offers an optimal balance between memory consumption and manipulation time.

This course is fundamental within the field of programming, since the proper use of data structures is critical in any application that handles large volumes of information or that has very strict efficiency requirements.

Previous courses in the field of programming have already introduced some basic data structures, such as lists, stacks, queues, or trees. This subject presents the concept of abstract data type (ATD) as a general model to describe a data structure and study its efficiency. Finally, the core of the course consists of learning to use each data structure properly and knowing how to select the most appropriate data structure for each situation.<h2>content</h2>The subject is structured in eight modules (module 8 of the subjects is not studied):

1. Abstract data types
containers
contract design
Developing a Sample Collection
Generic or parametric types
Library of thematic collections
Presentation of the rest of the modules
Study of the concept of TAD and aspects related to its definition and implementation in classes through a hierarchy.

2. Algorithmic complexity
Introduction to algorithmic complexity
Asymptotic notation for algorithmic complexity
Algorithmic complexity of abstract data types
Description of the methods used to compare the cost of different programs in terms of execution times or memory consumption.

3. Sequential containers
batteries
tails
chained representations
liza
Vector representations: resizing
Sequential Containers in the Java Collections Framework
Study of collections of objects with sequential access (stacks, queues, lists).

4. trees
General and binary trees. Definitions and related concepts
recursion
general trees
binary trees
excursions
An example file system
Presentation of data structures used to represent hierarchical relationships and introduction of the concept of recursion.

5. Priority queues
The priority queue concept
priority queue operation
Priority queue implementations
Priority queues in JDK libraries
Heap Sort: The Heapsort Algorithm
Usage example: Huffman algorithm
Study of the design and implementation of collections where the order of access to the elements depends on their priority.

6. The TAD table
Presentation of the TAD Table
Scatter implementation of the TAD Table
The Joint TAD
Application example: a symbol table for a modular language
Tables and sets in the Java Collections Framework
Study of the concept of dispersion, presentation of the TAD table and the strategies for its implementation.
7. Look for trees
search trees
Implementation of ordered collections with binary search trees
Multipath trees and B-trees
Search Trees in the Java Collections Framework
Deepening of the tree concept and its applications to represent ordered collections.
8. Graphics

(This module is not studied)

The concept of graph.
The abstract data type Graph
Java interfaces for directed and undirected graphs
Graph Implementation
Example of use: TAD Academy
Review of the concept of graphs and description of strategies to implement different types of graphs (directed or undirected, labeled or unlabeled,...).
9. Collection Libraries
Design of new TADs using a library of collections
Collection Library Design
Libraries of existing collections
Analysis of the design of new TADs from other existing ones. Study of the considerations that affect the design of collection libraries and presentation of some existing libraries (Java Collections Framework, Java Data Structure Library, ...).",Data structures design,"In this subject the different strategies of data representation in a computer and the criteria to evaluate them are studied. Depending on the type of treatment that has to be done with this information (size, access criteria, etc.), it will be possible to select the strategy that offers an optimal balance between memory consumption and manipulation time.

This course is fundamental within the field of programming, since the proper use of data structures is critical in any application that handles large volumes of information or that has very strict efficiency requirements.

Previous courses in the field of programming have already introduced some basic data structures, such as lists, stacks, queues, or trees. This subject presents the concept of abstract data type (ATD) as a general model to describe a data structure and study its efficiency. Finally, the core of the course consists of learning to use each data structure properly and knowing how to select the most appropriate data structure for each situation.","The subject is structured in eight modules (module 8 of the subjects is not studied):

1. Abstract data types
containers
contract design
Developing a Sample Collection
Generic or parametric types
Library of thematic collections
Presentation of the rest of the modules
Study of the concept of TAD and aspects related to its definition and implementation in classes through a hierarchy.

2. Algorithmic complexity
Introduction to algorithmic complexity
Asymptotic notation for algorithmic complexity
Algorithmic complexity of abstract data types
Description of the methods used to compare the cost of different programs in terms of execution times or memory consumption.

3. Sequential containers
batteries
tails
chained representations
liza
Vector representations: resizing
Sequential Containers in the Java Collections Framework
Study of collections of objects with sequential access (stacks, queues, lists).

4. trees
General and binary trees. Definitions and related concepts
recursion
general trees
binary trees
excursions
An example file system
Presentation of data structures used to represent hierarchical relationships and introduction of the concept of recursion.

5. Priority queues
The priority queue concept
priority queue operation
Priority queue implementations
Priority queues in JDK libraries
Heap Sort: The Heapsort Algorithm
Usage example: Huffman algorithm
Study of the design and implementation of collections where the order of access to the elements depends on their priority.

6. The TAD table
Presentation of the TAD Table
Scatter implementation of the TAD Table
The Joint TAD
Application example: a symbol table for a modular language
Tables and sets in the Java Collections Framework
Study of the concept of dispersion, presentation of the TAD table and the strategies for its implementation.
7. Look for trees
search trees
Implementation of ordered collections with binary search trees
Multipath trees and B-trees
Search Trees in the Java Collections Framework
Deepening of the tree concept and its applications to represent ordered collections.
8. Graphics

(This module is not studied)

The concept of graph.
The abstract data type Graph
Java interfaces for directed and undirected graphs
Graph Implementation
Example of use: TAD Academy
Review of the concept of graphs and description of strategies to implement different types of graphs (directed or undirected, labeled or unlabeled,...).
9. Collection Libraries
Design of new TADs using a library of collections
Collection Library Design
Libraries of existing collections
Analysis of the design of new TADs from other existing ones. Study of the considerations that affect the design of collection libraries and presentation of some existing libraries (Java Collections Framework, Java Data Structure Library, ...).",
242,UOC_Spain,22.4,"<h2>UOC_Spain 22.400</h2><h2>title</h2>Computational thinking<h2>summary</h2>This course is designed to prepare us to start in the world of programming, and to know and understand the basic concepts that will allow us to turn a specific problem into a small program that solves it.

In order to do so, we will first learn to think in such a way that we can identify what kinds of problems can be solved using a computer running through a sequence of steps designed to solve the proposed problem. That is, through what is known as computational thinking, we will know the abstract concepts that determine the appropriate reasoning to be able to solve problems through programs.

Next, we'll review programming languages, which have evolved very rapidly since the popularization of personal computers, and we'll also learn about other important elements of programming context and vocabulary, such as what a computer is and what its function is. basic function. .

Finally, we will see how to put it into practice by developing a small program in a guided way, introducing the different concepts that make up what is known as structured programming. To do this, we will use the Processing programming language, which was created with the aim of encouraging creativity and learning to program in a simple and attractive way.<h2>content</h2>The contents of the course are grouped into two blocks:

Computational thinking, or how we should think to solve a problem using a computer. In addition, the historical background, to know the context and basic vocabulary of the field of programming and what programming languages ​​are like.

Step-by-step guided programming project to create a first program using the Processing language and letting our creativity fly.",Computational thinking,"This course is designed to prepare us to start in the world of programming, and to know and understand the basic concepts that will allow us to turn a specific problem into a small program that solves it.

In order to do so, we will first learn to think in such a way that we can identify what kinds of problems can be solved using a computer running through a sequence of steps designed to solve the proposed problem. That is, through what is known as computational thinking, we will know the abstract concepts that determine the appropriate reasoning to be able to solve problems through programs.

Next, we'll review programming languages, which have evolved very rapidly since the popularization of personal computers, and we'll also learn about other important elements of programming context and vocabulary, such as what a computer is and what its function is. basic function. .

Finally, we will see how to put it into practice by developing a small program in a guided way, introducing the different concepts that make up what is known as structured programming. To do this, we will use the Processing programming language, which was created with the aim of encouraging creativity and learning to program in a simple and attractive way.","The contents of the course are grouped into two blocks:

Computational thinking, or how we should think to solve a problem using a computer. In addition, the historical background, to know the context and basic vocabulary of the field of programming and what programming languages ​​are like.

Step-by-step guided programming project to create a first program using the Processing language and letting our creativity fly.",
243,VirginiaTech_USA,CS3704,"<h2>VirginiaTech_USA CS3704</h2><h2>title</h2>Intermediate Software Design and Engineering<h2>content</h2>Explores the principles of software design in detail, with an emphasis on software engineering aspects. Includes exposure of software lifecycle activities including design, coding, testing, debugging, and maintenance, highlighting how design affects these activities. Peer reviews, designing for software reuse, CASE tools, and writing software to specifications are also covered.",Intermediate Software Design and Engineering,,"Explores the principles of software design in detail, with an emphasis on software engineering aspects. Includes exposure of software lifecycle activities including design, coding, testing, debugging, and maintenance, highlighting how design affects these activities. Peer reviews, designing for software reuse, CASE tools, and writing software to specifications are also covered.",
244,VirginiaTech_USA,CS3714,"<h2>VirginiaTech_USA CS3714</h2><h2>title</h2>Mobile Software Development<h2>content</h2>Technologies and concepts underlying software development for mobile devices (handheld computers). Mobile computing platforms, including architecture, operating system, and programming environment. Software design patterns and structuring for mobile applications. Network-centric mobile software development. Data persistence. Programming for mobile device components such as cameras, recorders, accelerometer, gyroscope and antennas. Location-aware software development.",Mobile Software Development,,"Technologies and concepts underlying software development for mobile devices (handheld computers). Mobile computing platforms, including architecture, operating system, and programming environment. Software design patterns and structuring for mobile applications. Network-centric mobile software development. Data persistence. Programming for mobile device components such as cameras, recorders, accelerometer, gyroscope and antennas. Location-aware software development.",
247,VirginiaTech_USA,CS3754,"<h2>VirginiaTech_USA CS3754</h2><h2>title</h2>Cloud Software Development<h2>content</h2>Fundamentals of cloud software development, including design patterns, application programming interfaces, and underlying middleware technologies. Development of distributed multi-tiered enterprise software applications that run on a server computer and are accessed using a web browser over the Internet on a network-connected computer such as desktop, laptop, or handheld computer (tablet, smartphone, or mobile device. A grade of C or better is required in prerequisite.",Cloud Software Development,,"Fundamentals of cloud software development, including design patterns, application programming interfaces, and underlying middleware technologies. Development of distributed multi-tiered enterprise software applications that run on a server computer and are accessed using a web browser over the Internet on a network-connected computer such as desktop, laptop, or handheld computer (tablet, smartphone, or mobile device. A grade of C or better is required in prerequisite.",
249,VirginiaTech_USA,CS4104,<h2>VirginiaTech_USA CS4104</h2><h2>title</h2>Data and Algorithm Analysis<h2>content</h2>Data structures and algorithms from an analytical perspective. Theoretical analysis of algorithm efficiency. Comparing algorithms with respect to space and run-time requirements. Analytical methods for describing theoretical and practical bounds on performance. Constraints affecting problem solvability.,Data and Algorithm Analysis,,Data structures and algorithms from an analytical perspective. Theoretical analysis of algorithm efficiency. Comparing algorithms with respect to space and run-time requirements. Analytical methods for describing theoretical and practical bounds on performance. Constraints affecting problem solvability.,
253,VirginiaTech_USA,CS4144,"<h2>VirginiaTech_USA CS4144</h2><h2>title</h2>Competitive Problem Solving II<h2>content</h2>Deeper treatment of advanced algorithms, data structures, and implementation techniques, taught in a setting that combines collaborative practice with competitive exercise. Students practice to solve problems using a computer, which are judged by automated evaluation software for correctness and efficiency. Practice with advanced searching and graph algorithms, advanced dynamic programming, linear programming techniques, computational geometry, and numerical algorithms. Problems are drawn from multiple areas in computer science. Macro- and micro optimization techniques to improve efficiency are emphasized.",Competitive Problem Solving II,,"Deeper treatment of advanced algorithms, data structures, and implementation techniques, taught in a setting that combines collaborative practice with competitive exercise. Students practice to solve problems using a computer, which are judged by automated evaluation software for correctness and efficiency. Practice with advanced searching and graph algorithms, advanced dynamic programming, linear programming techniques, computational geometry, and numerical algorithms. Problems are drawn from multiple areas in computer science. Macro- and micro optimization techniques to improve efficiency are emphasized.",
261,VirginiaTech_USA,CS4144,"<h2>VirginiaTech_USA CS4144</h2><h2>title</h2>Competitive Problem Solving II<h2>content</h2>Deeper treatment of advanced algorithms, data structures, and implementation techniques, taught in a setting that combines collaborative practice with competitive exercise. Students practice to solve problems using a computer, which are judged by automated evaluation software for correctness and efficiency. Practice with advanced searching and graph algorithms, advanced dynamic programming, linear programming techniques, computational geometry, and numerical algorithms. Problems are drawn from multiple areas in computer science. Macro- and micro optimization techniques to improve efficiency are emphasized.",Competitive Problem Solving II,,"Deeper treatment of advanced algorithms, data structures, and implementation techniques, taught in a setting that combines collaborative practice with competitive exercise. Students practice to solve problems using a computer, which are judged by automated evaluation software for correctness and efficiency. Practice with advanced searching and graph algorithms, advanced dynamic programming, linear programming techniques, computational geometry, and numerical algorithms. Problems are drawn from multiple areas in computer science. Macro- and micro optimization techniques to improve efficiency are emphasized.",
